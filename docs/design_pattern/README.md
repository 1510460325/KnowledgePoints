## 设计模式
* 创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。
* 结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。
* 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
### 创建型模式（5种）
* 工厂方法模式：工厂方法模式中是一个子类对应一个工厂类，而这些工厂类都实现于一个抽象接口。  
![工厂模式](./imgs/1.png)  
步骤为：拿到具体工厂类 =\> 拿到具体对象
* 抽象工厂模式：当有多个抽象角色时，使用的一种工厂模式。  
![工厂模式](imgs/2.jpg)  
步骤为：拿到具体大抽象工厂 =\> 拿到子工厂类 =\> 拿到具体对象
* 单例模式(双重检测模式)
~~~
public class Singleton {
	private static Singleton singleton;
	static Singleton getInstance(){
		if (singleton == null) {
			synchronized(Singleton.class) {
				if (singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
~~~
* 建造者模式：在生成多成员的类中可以实现随机组装成员  
![建造者模式](imgs/3.jpg)  
* 原型模式：生成克隆对象，适用重新生成相同对象成本大的场景
### 结构型模式（7种）
* 适配器模式：对于不能直接调用的场景，像做了一个代理，转发调用  
例子：读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。
* 装饰器模式：就是对已经存在的某些类进行装饰，以此来扩展一些功能
* 代理模式：包装一个类，转发请求
* 外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。整合所有子系统
* 桥接模式：将类的功能层次结构和实现层次结构相分离  
![桥接模式](imgs/4.png)  
* 组合模式：对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局
* 享元模式：主要用于减少创建对象的数量  
![享元模式](imgs/5.png)  
### 行为型模式（11种）
* 策略模式：定义具体实施代码逻辑，通过外部传参的方式实现不同执行逻辑  
![享元模式](imgs/6.png)  
* 模板方法模式：父类定义抽象函数，定义的逻辑骨架中调用抽象函数，实质是调用子类的实现。
* 观察者模式：监听模式，将自己加入到其他对象的监听列表中，执行自己的更新函数，回调方式
* 迭代器模式：实现迭代遍历Iterator
* 责任链模式：
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
* 解释器模式