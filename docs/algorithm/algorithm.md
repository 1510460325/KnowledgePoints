### B树
B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： 
* 每个结点至多有m个子结点； 
* 除根结点和叶结点外，其它每个结点至少有ceil(m/2)个子结点； 
* 根结点至少有两个子结点；（唯一例外的是根结点就是叶子结点） 
* 所有的叶结点在同一层； 
* 有k个子结点的非根结点恰好包含k-1个关键码，关键码按照递增次序进行排列。

![样例](./imgs/1.png)
* 查询
~~~
B-Tree_Search(x, k)
	i = 1
	//找出最小下标 i ，使得 x.key[i] >= k
	while i <= x.n && x.key[i] < k                  
		i = i + 1
	//检查是否找到该关键字，找到则返回，否则后面结束此次查找
	if i <= x.n && k == x.key[i]
		return (x, i)
	else if x.leaf
		return null
	else DISK-READ(x, c[i])
		return B-Tree_Search(x.c[i], k)
~~~
插入：
* 自上而下查找插入叶结点位置；
* 如果插入的自下而上分裂满结点，如果叶子节点满度，达到2t-1
![样例](./imgs/2.png)
删除：核心思想还是删除叶子节点
* 叶子节点
    * 当前节点的key数量不是最低 -> 直接删除
    * 当前节点的key数量已是最低
        * 如果有右兄弟 -> 父节点合并到右兄弟（满度就再分割）
        * 如果没右兄弟 -> 则合并到左兄弟结点中（满度就再分割）
* 如果是非叶子节点
    * 找到后继叶子节点，交换位置，删除叶子节点
![样例](./imgs/3.png)
![样例](./imgs/4.png)
![样例](./imgs/5.png)
### B+树
定义：
* 则除了根之外的每个节点都包含最少m/2个元素最多m-1个元素
* 对于所有内部节点，子节点的数目总是比元素的数目多一个
* 所有中间节点key都在叶子节点中,左边界或者右边界
* 所有的叶子节点是链接起来的
![样例](./imgs/6.png)
插入：
* 如果没有满度 -> 直接插入
* 如果满度 -> 分割将中间元素的key复制到父节点
删除：
* 如果当前节点不是最低值 -> 直接删除
* 如果当前节点已是最低值
    * 左兄弟有富余，移过来，更新父节点的key为所借的key
    * 左兄弟没有富余(包括没有左兄弟)删除节点和索引key

![样例](./imgs/7.png)  
![样例](./imgs/8.png)  
![样例](./imgs/9.png)  
![样例](./imgs/10.png)  
![样例](./imgs/11.png)  
![样例](./imgs/12.png)  
B+树的优势：
* 单一节点存储更多的元素，使得查询的IO次数更少。
* 所有查询都要查找到叶子节点，查询性能稳定。
* 所有叶子节点形成有序链表，便于范围查询。
### 二叉树
### 红黑树
### 动态规划
### 贪心算法
### 排序算法