### B树
B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： 
* 每个结点至多有m个子结点； 
* 除根结点和叶结点外，其它每个结点至少有ceil(m/2)个子结点； 
* 根结点至少有两个子结点；（唯一例外的是根结点就是叶子结点） 
* 所有的叶结点在同一层； 
* 有k个子结点的非根结点恰好包含k-1个关键码，关键码按照递增次序进行排列。

![样例](./imgs/1.png)
* 查询
~~~
B-Tree_Search(x, k)
	i = 1
	//找出最小下标 i ，使得 x.key[i] >= k
	while i <= x.n && x.key[i] < k                  
		i = i + 1
	//检查是否找到该关键字，找到则返回，否则后面结束此次查找
	if i <= x.n && k == x.key[i]
		return (x, i)
	else if x.leaf
		return null
	else DISK-READ(x, c[i])
		return B-Tree_Search(x.c[i], k)
~~~
插入：
* 自上而下查找插入叶结点位置；
* 如果插入的自下而上分裂满结点，如果叶子节点满度，达到2t-1
![样例](./imgs/2.png)
删除：核心思想还是删除叶子节点
* 叶子节点
    * 当前节点的key数量不是最低 -> 直接删除
    * 当前节点的key数量已是最低
        * 如果有右兄弟 -> 父节点合并到右兄弟（满度就再分割）
        * 如果没右兄弟 -> 则合并到左兄弟结点中（满度就再分割）
* 如果是非叶子节点
    * 找到后继叶子节点，交换位置，删除叶子节点
    
![样例](./imgs/3.png)

![样例](./imgs/4.png)  

![样例](./imgs/5.png)    
查询效率：logm(n)
### B+树
定义：
* 则除了根之外的每个节点都包含最少m/2个元素最多m-1个元素
* 对于所有内部节点，子节点的数目总是比元素的数目多一个
* 所有中间节点key都在叶子节点中,左边界或者右边界
* 所有的叶子节点是链接起来的
![样例](./imgs/6.png)
插入：
* 如果没有满度 -> 直接插入
* 如果满度 -> 分割将中间元素的key复制到父节点
删除：
* 如果当前节点不是最低值 -> 直接删除
* 如果当前节点已是最低值
    * 左兄弟有富余，移过来，更新父节点的key为所借的key
    * 左兄弟没有富余(包括没有左兄弟)删除节点和索引key

![样例](./imgs/7.png)  
![样例](./imgs/8.png)  
![样例](./imgs/9.png)  
![样例](./imgs/10.png)  
![样例](./imgs/11.png)  
![样例](./imgs/12.png)  
B+树的优势：
* 单一节点存储更多的元素，使得查询的IO次数更少。
* 所有查询都要查找到叶子节点，查询性能稳定。
* 所有叶子节点形成有序链表，便于范围查询。  

查询效率：logm(n)
### 二叉树
定义：每个节点都最多有孩子，查找效率（log2(n)）
#### 特殊二叉树
* 完全二叉树：除了最后一层外，所有的节点都是满的，且最底层是从左到右排放
* 满二叉树：除了最后一层所有节点都有两个节点，最后一层无孩子
* 平衡二叉树：左右子树的高度绝对值不超过1
### 红黑树
* 每个节点要么是红要么是黑
* 根节点是黑色的
* 所有叶子节点都是黑色的空节点
* 红色节点的子节点必须是两个黑色节点
* 每个节点中所有到叶子节点的黑色节点数相等

查找效率：log2(n)
### 动态规划
大问题的最优解依赖于小问题的最优解。dp[i] = dp[i - 5] + n;
### 贪心算法
确保当前的做法是最优的，那么能保证最后的解是最优的
### 排序算法
* 冒泡：每次循环确定最大值 n²
* 归并：先分，排好序后再合 nlogn
* 快排：每次确定一个位置的元素，在递归排序前后阶段 nlogn
* 堆排序：每次确定最大的元素，和最后的替换，再下数 nlogn
    * 建堆过程：从最后的父节点开始下树 nlogn/2
* 插入：每次选定当前点插入到已经有序的列表里 n²
* 希尔排序：不断缩小间距的插入排序 * 
* 桶排：先分成小桶，排好序之后，统一起来 *
* 计数排序：对数据进行计数，输出时从小到大 *